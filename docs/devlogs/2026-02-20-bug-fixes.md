# AIVim Bug 修复日志

**日期**: 2026-02-20  
**提交**: 146c8f9, 38cdd20  
**主题**: Insert 模式字符顺序、w/b 命令修复

---

## Bug #1: Insert 模式字符顺序错误

### 现象
在 `i` 或 `a` 模式下输入多个字符时，第一个字符后的字符会出现在第一个字符前面。

例如输入 "abc"，期望得到 "abc"，实际得到 "cba"。

### 根因分析

原来的实现使用了 `insert_after_cursor` 标志来处理 `a` 命令在行尾的情况：

```rust
pub fn insert_char(&mut self, ch: char) {
    if self.mode.is_insert() {
        // 检查是否需要在光标后插入
        if self.insert_after_cursor {
            self.insert_char_after_cursor(ch);
            self.insert_after_cursor = false;  // 重置标志！
            return;
        }
        // ... 正常插入逻辑
    }
}
```

**问题**：
1. 第一次插入时，`insert_after_cursor = true`，调用 `insert_char_after_cursor`
2. 标志被重置为 `false`
3. 第二次插入时，使用正常的 `insert_char` 逻辑
4. 但光标位置没有正确更新，导致插入位置错误

### 修复方案

**核心思想**：简化设计，移除标志，改为在 Insert 模式下允许光标位于 `line_len` 位置。

#### 修改 1: 移除 `insert_after_cursor` 标志

```rust
pub struct Editor {
    // ... 其他字段
    // 删除: insert_after_cursor: bool,
}
```

#### 修改 2: 简化 `insert_char` 逻辑

```rust
pub fn insert_char(&mut self, ch: char) {
    if self.mode.is_insert() {
        let cursor_line = self.cursor.line;
        let cursor_col = self.cursor.column;

        // 计算插入位置
        // 在 Insert 模式下，光标可以在 line_len 位置（最后一个字符之后）
        let char_idx = {
            let buffer = self.current_buffer();
            let line_start = buffer.line_to_char(cursor_line);
            let line_len = buffer.line_len(cursor_line);
            // 如果光标在 line_len 位置，在最后一个字符之后插入
            // 否则，在当前光标位置插入
            line_start + cursor_col.min(line_len)
        };

        let buffer = self.current_buffer_mut();
        buffer.insert_char(char_idx, ch);

        // 更新光标位置
        let line_len = buffer.line_len(cursor_line);
        // 在 Insert 模式下，光标可以在 line_len 位置（最后一个字符之后）
        self.cursor.column = (cursor_col + 1).min(line_len);
        self.cursor.preferred_column = Some(self.cursor.column);
    }
}
```

#### 修改 3: 修改 `enter_append_mode`

```rust
pub fn enter_append_mode(&mut self) {
    let buffer = self.current_buffer();
    let line_len = buffer.line_len(self.cursor.line);
    let max_col = line_len.saturating_sub(1);
    let at_end = self.cursor.column >= max_col;

    if at_end {
        // 在行尾：将光标设置为 line_len（在最后一个字符之后）
        // 这样在 Insert 模式下，to_char_idx 会返回正确的插入位置
        self.cursor.column = line_len;
        self.set_mode(Mode::Insert);
    } else {
        // 不在行尾：向右移动一位，然后进入 Insert 模式
        drop(buffer);
        self.execute_motion(Motion::Right);
        self.set_mode(Mode::Insert);
    }
}
```

### 测试结果

| 场景 | 输入 | 结果 | 状态 |
|------|------|------|------|
| `i` 模式 | "abc" | "abcHello" | ✅ |
| `a` 模式（行首） | "xyz" | "Hxyzello" | ✅ |
| `a` 模式（行尾） | "!?x" | "Hi!?x" | ✅ |

---

## Bug #2: w 命令跨越行边界

### 现象
当光标在当前行最后一个单词时，按 `w` 会跳到下一行的行头。

用户期望：`w` 应该停留在当前行，方便配合 `a` 命令追加内容。

### 根因分析

原来的 `move_word_forward` 实现会跳过所有空白字符（包括换行符）：

```rust
fn move_word_forward(cursor: &mut Cursor, buffer: &Buffer) {
    // ... 跳过当前单词
    // ... 跳过标点
    // ... 跳过空白字符（包括换行！）
    while let Some(&ch) = chars.peek() {
        if ch.is_whitespace() {  // 包括 '\n'
            chars.next();
        } else {
            break;
        }
    }
    // 结果：跳到了下一行
}
```

### 修复方案

限制 `w` 命令只在本行内查找下一个单词：

```rust
fn move_word_forward(cursor: &mut Cursor, buffer: &Buffer) {
    let current_line = cursor.line;
    let current_col = cursor.column;
    let line_text = buffer.line(current_line).map(|l| l.to_string()).unwrap_or_default();
    
    // 移除行尾换行符
    let line_text = line_text.strip_suffix('\n').unwrap_or(&line_text);
    
    if current_col >= line_text.len() {
        // 已经在行尾，不移动到下一行，保持在当前位置
        return;
    }
    
    let remaining = &line_text[current_col..];
    let mut chars = remaining.chars().peekable();
    
    // 跳过当前单词的剩余部分
    while let Some(&ch) = chars.peek() {
        if ch.is_alphanumeric() || ch == '_' {
            chars.next();
        } else {
            break;
        }
    }
    
    // 跳过标点符号
    while let Some(&ch) = chars.peek() {
        if !ch.is_alphanumeric() && ch != '_' && !ch.is_whitespace() {
            chars.next();
        } else {
            break;
        }
    }
    
    // 跳过空白字符（但不包括换行，因为我们只在本行内移动）
    while let Some(&ch) = chars.peek() {
        if ch.is_whitespace() && ch != '\n' {
            chars.next();
        } else {
            break;
        }
    }
    
    let consumed = remaining.len() - chars.collect::<String>().len();
    let new_col = current_col + consumed;
    
    // 确保不超出本行范围
    let final_col = new_col.min(line_text.len().saturating_sub(1));
    cursor.column = final_col;
    cursor.update_preferred_column();
}
```

### 关键改动

1. **只在本行内操作**：获取当前行文本，不跨越行边界
2. **检查行尾**：如果已经在行尾，直接返回，不移动
3. **限制光标位置**：确保新位置不超过本行范围

### 测试结果

| 操作 | 光标位置 | 结果 | 状态 |
|------|----------|------|------|
| 第1次 w | col=0 | col=6 (到 "world") | ✅ |
| 第2次 w | col=6 | col=10 (到 "world" 末尾) | ✅ |
| 第3次 w | col=10 | col=10 (保持，不跳行) | ✅ |
| w + a | - | 可在当前单词后追加 | ✅ |

---

## Bug #3: b 命令跨越行边界

### 现象
当光标在行头时，按 `b` 会跳到前一行的最后一个单词开头。

用户期望：`b` 应该停留在当前行，不跨越行边界（与 `w` 命令行为一致）。

### 根因分析

原来的 `move_word_backward` 实现使用了整个 buffer 的文本：

```rust
fn move_word_backward(cursor: &mut Cursor, buffer: &Buffer) {
    let char_idx = cursor.to_char_idx(buffer);
    let text = buffer.rope().to_string();
    let preceding = &text[..char_idx];  // 包括前一行的文本！
    // ... 处理逻辑会跨越行边界
}
```

当光标在行头时，`preceding` 包含了前一行的所有文本，导致 `b` 命令跳到了前一行的单词。

### 修复方案

限制 `b` 命令只在本行内操作，与 `w` 命令保持一致：

```rust
fn move_word_backward(cursor: &mut Cursor, buffer: &Buffer) {
    let current_line = cursor.line;
    let current_col = cursor.column;
    
    // 如果已经在行首，不移动到上一行
    if current_col == 0 {
        return;
    }
    
    let line_text = buffer.line(current_line).map(|l| l.to_string()).unwrap_or_default();
    
    // 移除行尾换行符
    let line_text = line_text.strip_suffix('\n').unwrap_or(&line_text);
    
    // 获取当前位置之前的文本（只在本行内）
    let preceding = &line_text[..current_col.min(line_text.len())];
    let mut chars: Vec<char> = preceding.chars().collect();
    
    // 跳过空白字符
    while let Some(&ch) = chars.last() {
        if ch.is_whitespace() {
            chars.pop();
        } else {
            break;
        }
    }
    
    // 跳过标点符号
    while let Some(&ch) = chars.last() {
        if !ch.is_alphanumeric() && ch != '_' && !ch.is_whitespace() {
            chars.pop();
        } else {
            break;
        }
    }
    
    // 跳过单词
    while let Some(&ch) = chars.last() {
        if ch.is_alphanumeric() || ch == '_' {
            chars.pop();
        } else {
            break;
        }
    }
    
    let new_col = chars.len();
    cursor.column = new_col;
    cursor.update_preferred_column();
}
```

### 关键改动

1. **只在本行内操作**：使用 `buffer.line()` 获取当前行文本
2. **检查行首**：如果 `current_col == 0`，直接返回，不移动
3. **限制处理范围**：`preceding` 只包含当前行光标之前的文本

### 测试结果

| 场景 | 光标位置 | 结果 | 状态 |
|------|----------|------|------|
| 在行头按 b | line=1, col=0 | line=1, col=0 (保持) | ✅ |
| 多次按 b | line=1, col=0 | line=1, col=0 (不跳行) | ✅ |

---

## 技术要点

### 1. 光标位置语义

不同模式下光标的语义不同：

| 模式 | 光标位置 | 含义 |
|------|----------|------|
| Normal | 0 到 line_len-1 | 在字符上 |
| Insert | 0 到 line_len | 在字符之间 |

修复后的实现正确处理了这种差异。

### 2. 简化设计原则

**旧设计**：
- 使用标志 `insert_after_cursor` 来区分特殊情况
- 需要维护状态，容易出错

**新设计**：
- 允许光标在 Insert 模式下位于 `line_len`
- 统一处理逻辑，无需特殊标志
- 更简单，更可靠

### 3. 边界处理

修复中特别注意了边界情况：
- 空行处理
- 单行文本
- 光标在行首/行尾的情况
- 多字节字符（待测试）
- w/b 命令的行边界处理

---

## 回归测试

建议的测试用例：

```rust
#[test]
fn test_insert_mode_multiple_chars() {
    let mut editor = Editor::new();
    editor.open_file(Path::new("test.txt")).unwrap();
    
    // i 模式
    editor.set_mode(Mode::Insert);
    for c in "abc".chars() {
        editor.insert_char(c);
    }
    assert_eq!(editor.current_buffer().to_string(), "abcHello");
    
    // a 模式（行尾）
    editor.open_file(Path::new("test2.txt")).unwrap();
    editor.execute_motion(Motion::Right);
    editor.enter_append_mode();
    for c in "xyz".chars() {
        editor.insert_char(c);
    }
    assert_eq!(editor.current_buffer().to_string(), "Hixyz");
}

#[test]
fn test_word_motion_no_cross_line() {
    let mut editor = Editor::new();
    editor.open_file(Path::new("test.txt")).unwrap();
    
    // 假设文件内容是 "hello world\nsecond line"
    editor.execute_motion(Motion::WordForward);  // 到 "hello"
    editor.execute_motion(Motion::WordForward);  // 到 "world"
    editor.execute_motion(Motion::WordForward);  // 应该保持，不跳行
    
    assert_eq!(editor.cursor().line, 0);  // 仍在第一行
}
```

---

## 经验教训

1. **状态管理**：使用标志位会增加复杂性，尽量通过数据结构的设计来避免
2. **边界测试**：编辑器操作涉及大量边界情况，需要充分测试
3. **用户反馈**：用户的使用习惯（如 `w` 不跳行）是重要的设计参考
4. **简化设计**：当发现代码变得复杂时，考虑重新设计，而不是添加更多补丁

---

**修复者**: AI Assistant  
**审核**: 用户测试反馈  
**状态**: ✅ 已修复并提交
